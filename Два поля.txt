#include <iostream>
#include <stdio.h> 
#include <math.h>
#include <string>
#include <fstream>
#include <windows.h> 
#include <time.h>
#include <conio.h>


using namespace std;

const int N = 10; // размерность массива (поля)
const int NUM_SHIPS = 9;

int Ships_id = 1; // индификатор корабля
int Ships[10] = { 0 }; // целочисленный массив состоящий из 9 кораблей

// Функция переставляет курсор в заданной координате
void gotoxy(int x, int y)
{
	COORD p = { x, y };
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), p);
}

void ship_show(int x, int y, int dir, int size_ship)
{
	for (int i = 0; i < size_ship; i++)
	{
		gotoxy(x + 1, y + 1);
		cout << '#';

		switch (dir)
		{
		case 0:
			x++;
			break;
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		}
	}
};
// Функция проверки расположения корабля на карте
bool ship_in_map(int x, int y, int dir, int size_ship)
{
	bool in_map = 1; // флаг, по-умолчанию инициализируется начальное значение 1

		// проверка возможности постановки корабля
	for (int i = 0; i < size_ship; i++)
	{
		if (x < 0 || y < 0 || x >= N || y >= N)
		{
			in_map = 0; // "флаг", если постановка возможнна то флаг обнуляется. обнуляется начальное значение 1 если x и y окажутся за пределами границ массива
			break;
		}
		switch (dir)
		{
		case 0:
			x++;
			break;
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		}
	}
	return in_map;
}

// функция проверки постановки корабля
bool set_ship(int map[N][N], int x, int y, int dir, int size_ship)
{
	int temp_x = x; // временная переменная для хранения первоначальных координат x;
	int temp_y = y; // временная переменная для хранения первоначальных координат y;
	//int count_ship = 0; // инициализированная целочисленная переменная для подсчета кораблей 
	bool setting_is_possible = 1;

	// проверка возможности постановки корабля
	for (int i = 0; i < size_ship; i++)
	{
		if (x < 0 || y < 0 || x >= N || y >= N)
		{
			setting_is_possible = 0;
			break;
		}
		// условие проверки координат ячеек вокруг корабля
		if (map[x][y] >= 1 ||
			map[x][y + 1] >= 1 ||
			map[x][y - 1] >= 1 ||
			map[x + 1][y] >= 1 ||
			map[x + 1][y + 1] >= 1 ||
			map[x + 1][y - 1] >= 1 ||
			map[x - 1][y] >= 1 ||
			map[x - 1][y + 1] >= 1 ||
			map[x - 1][y - 1] >= 1)
		{
			setting_is_possible = 0;
			break;
		}
		switch (dir)
		{
		case 0:
			x++;
			break;
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		}
	}
	// если есть возможность поставить корабль ставим
	if (setting_is_possible == 1) // условие, которое проверяет значение флага; если постановка корабля возможна, тогда только в этом случае будет производится запись
	{
		// расстановка начнется с нужных координат

		x = temp_x; // восстанавливаем значение переменных temp_x;
		y = temp_y; // восстанавливаем значение переменных temp_y;

		for (int i = 0; i < size_ship; i++)
		{
			map[x][y] = Ships_id; // записываем на карту индификатор корабля

			switch (dir)
			{
				// взависимости от направления меняем координату
			case 0:
				x++; // растет слева направо
				break;
			case 1:
				y++; // увеличиваем сверху вниз (от 0 до 24)
				break;
			case 2:
				x--; // уменьшаем, растет влево
				break;
			case 3:
				y--; // уменьшаем, растет вверх
				break;
			}
		}

		Ships[Ships_id] = size_ship;

		Ships_id++;
		//count_ship++; // счетчик, который подсчитывает кол-во удачно установленных кораблей
	}
	return setting_is_possible;
}

void set_rand_ships(int map[N][N], int size_ship, int ship_id) // функция для установки случайных кораблей.
{

	int x, y;// объявляем переменные для хранения координатов первичного поля, поля от которого будет начинаться наращивание корабля
	int dir = 0; // переменная куда будет записываться значение случайного направления
	int count_ship = 0; // инициализированная целочисленная переменная для подсчета кораблей 

	int count_tact = 0; // счетчик числа тактов цикла while

	// второй цикл (определяем число кораблей)
	while (count_ship < 1)
	{
		count_tact++;

		if (count_tact > 100)
		{
			break;
		}

		// первичная позиция (генерация случайных координат)

		x = rand() % N;
		y = rand() % N;

		int temp_x = x; // временная переменная для хранения первоначальных координат x;
		int temp_y = y; // временная переменная для хранения первоначальных координат y;


		// генерация направления
		dir = rand() % 4; // генерируется случайное значение от нуля до трех

		bool setting_is_possible = 1; // флаг, по-умолчанию инициализируется начальное значение 1

		// проверка возможности постановки корабля
		for (int i = 0; i < size_ship; i++)
		{
			if (x < 0 || y < 0 || x >= N || y >= N)
			{
				setting_is_possible = 0; // "флаг", если постановка возможнна то флаг обнуляется. обнуляется начальное значение 1 если x и y окажутся за пределами границ массива
				break;
			}
			// условие проверки координат ячеек вокруг корабля
			if (map[x][y] >= 1 ||
				map[x][y + 1] >= 1 ||
				map[x][y - 1] >= 1 ||
				map[x + 1][y] >= 1 ||
				map[x + 1][y + 1] >= 1 ||
				map[x + 1][y - 1] >= 1 ||
				map[x - 1][y] >= 1 ||
				map[x - 1][y + 1] >= 1 ||
				map[x - 1][y - 1] >= 1)
			{
				setting_is_possible = 0;
				break;
			}
			switch (dir)
			{
			case 0:
				x++;
				break;
			case 1:
				y++;
				break;
			case 2:
				x--;
				break;
			case 3:
				y--;
				break;
			}
		}
		// если есть возможность поставить корабль ставим
		if (setting_is_possible == 1) // условие, которое проверяет значение флага; если постановка корабля возможна, тогда только в этом случае будет производится запись
		{
			// расстановка начнется с нужных координат

			x = temp_x; // восстанавливаем значение переменных temp_x;
			y = temp_y; // восстанавливаем значение переменных temp_y;

			for (int i = 0; i < size_ship; i++)
			{
				map[x][y] = ship_id; // записываем на карту индификатор корабля

				switch (dir)
				{
					// взависимости от направления меняем координату
				case 0:
					x++; // растет слева направо
					break;
				case 1:
					y++; // увеличиваем сверху вниз (от 0 до 24)
					break;
				case 2:
					x--; // уменьшаем, растет влево
					break;
				case 3:
					y--; // уменьшаем, растет вверх
					break;
				}
			}

			count_ship++; // счетчик, который подсчитывает кол-во удачно установленных кораблей
		}
	}
}

void map_show(int map[N][N], int mask[N][N], bool useMask) // данная функция выводит 1 параметр - ссылку на 2-х мерный массив map (игровое поле) на экран;
{
	// прорисовка поля и кораблей (используем вложенный цикл)
	// нумерация поля (строки)
	cout << ' ';
	for (int i = 0; i < N; i++)
	{
		cout << i;
	}
	cout << endl;
	for (int i = 0; i < N; i++)
	{
		// нумерация поля (столбцы)
		cout << i;

		for (int j = 0; j < N; j++)// проходим по всем элементам двухмерного массива map
		{
			// анализ соответствующей ячейки маски
			if (mask[j][i] == 1 || useMask == 0) // если равна 1 то выодим на экран содержимое массива map
			{
				if (map[j][i] == 0) // если ячейка равна нулю, то выводим прочерк - в остальных случаях корабль
				{
					cout << '-';
				}
				else if (map[j][i] == -1) // условие для маркировки корабля
				{
					cout << "X";
				}
				else if (map[j][i] == -2) // условие для маркировки клетки, где нет корабля
				{
					cout << ".";
				}
				else
				{
					cout << map[j][i];
				}
			}
			// если содержимое маски 0, то выводим на экран пробел ("туман войны")
			else
			{
				cout << ' ';
			}
		}
		cout << endl;
	}
}
// функция для реализации стрельбы
int shot(int map[N][N], int x, int y, int ships[NUM_SHIPS + 1], int mask[N][N])
{
	int result = 0; // переменная для определения результата стрельбы

	if (map[x][y] >= 1)
	{
		ships[map[x][y]]--;
		// проверка жизней
		if (ships[map[x][y]] <= 0)
		{
			result = 2;
		}
		else
		{
			result = 1;
		}
		map[x][y] = -1; // помечаем палубу в которую попали
	}
	else
	{
		map[x][y] = -2; // отмечаем выстрел по карте
	}

	mask[x][y] = 1; // помечаем ячейку единицей в случае попадания и отображаем её на экран

	return result; // возвращаем result как результат работы функции
}

int main() {

	setlocale(LC_ALL, "Russian");

	while (true)
	{
		int map[N][N] = { 0 };
		int map2[N][N] = { 0 };

		int ships1[NUM_SHIPS + 1] = { 0, 4, 3, 3, 3, 2, 2, 2, 1, 1 };
		int ships2[NUM_SHIPS + 1] = { 0, 4, 3, 3, 3, 2, 2, 2, 1, 1 };

		int mask[N][N] = { 0 }; // маска для поля человека
		int mask2[N][N] = { 0 }; // маска для поля компьютера



		//блок вызова функции и создания кораблей рандомно
		//вызываем функцию и передаем в нее 3 параметра: 1 - массив map(передаем его по ссылке), 2 - размер корабля, 3 - кол-во кораблей. корабль 4-х палубный - 1 шт.

		for (int i = 1; i <= NUM_SHIPS; i++)
		{
			set_rand_ships(map, ships1[i], i);
		}

		for (int i = 1; i <= NUM_SHIPS; i++)
		{
			set_rand_ships(map2, ships2[i], i);
		}

		int x = 0, y = 0; // переменные определяют начальную палубу корабля
		int dir = 0; // переменная отвечающая за направление корабля: 0 - горизонтальное направление, 1 - вертикальное.
		int size_ship = 4; // определяем размер корабля
		int ch;

		// цикл переключения ввода между игроками
		bool turn = 1; // флаг, с помощью которого будет осуществляться передача хода.

		while (true)
		{
			int resultShot = 0;

			//Цикл отвечающий за стрельбу одного из игроков(Человека или ПК)
			do
			{
				map_show(map, mask, 0);
				cout << endl;
				map_show(map2, mask2, 1);

				if (turn == 1)
				{
					cout << endl << "Введите координаты цели: ";
					cin >> x;
					cin >> y;
					resultShot = shot(map2, x, y, ships2, mask2); // вызов функции shot
				}

				else
				{
					cout << endl << "Ход компьютера";
					cout << endl;
					Sleep(3000);
					x = rand() % N;
					y = rand() % N;
					resultShot = shot(map, x, y, ships1, mask);

				}

				// условия проверки: попал или не попал
				if (resultShot == 1)
				{
					cout << "Ранен" << endl;
				}

				else if (resultShot == 2)
				{
					cout << "Убит" << endl;
				}

				else
				{
					cout << "Промах" << endl;
				}

				Sleep(3000);
				system("cls"); // очищаем консольное окно

			} while (resultShot != 0);

			turn = !turn; // инвертируем значение переменной turn для передачи хода
		}
	}

	system("pause");

	return 0;

}