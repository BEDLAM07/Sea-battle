#include <iostream>
#include <stdio.h> 
#include <math.h>
#include <string>
#include <fstream>
#include <windows.h> 
#include <time.h>
#include <conio.h>

using namespace std;

const int N = 10; // размерность массива (поля)

int Ships_id = 1; // индификатор корабля
int Ships[10] = { 0 }; // целочисленный массив состоящий из 9 кораблей

void set_rand_ships(int map[N][N], int size_ship, int num_ships) // функция для установки случайных кораблей.
{
	
	int x, y;// объявляем переменные для хранения координатов первичного поля, поля от которого будет начинаться наращивание корабля
	int dir = 0; // переменная куда будет записываться значение случайного направления
	int count_ship = 0; // инициализированная целочисленная переменная для подсчета кораблей 

	int count_tact = 0; // счетчик числа тактов цикла while

	// второй цикл (определяем число кораблей)
	while (count_ship < num_ships)
	{
		count_tact++;

		if (count_tact > 100)
		{
			break;
		}

		// первичная позиция (генерация случайных координат)

		x = rand() % N; 
		y = rand() % N;

		int temp_x = x; // временная переменная для хранения первоначальных координат x;
		int temp_y = y; // временная переменная для хранения первоначальных координат y;


		// генерация направления
		dir = rand() % 4; // генерируется случайное значение от нуля до трех

		bool setting_is_possible = 1; // флаг, по-умолчанию инициализируется начальное значение 1

		// проверка возможности постановки корабля
		for (int i = 0; i < size_ship; i++)
		{
			if (x < 0 || y < 0 || x >= N || y >= N)
			{
				setting_is_possible = 0; // "флаг", если постановка возможнна то флаг обнуляется. обнуляется начальное значение 1 если x и y окажутся за пределами границ массива
				break;
			}
			// условие проверки координат ячеек вокруг корабля
			if (map[x][y] >= 1 ||
				map[x][y + 1] >= 1 ||
				map[x][y - 1] >= 1 ||
				map[x + 1][y] >= 1 ||
				map[x + 1][y + 1] >= 1 ||
				map[x + 1][y - 1] >= 1 ||
				map[x - 1][y] >= 1 ||
				map[x - 1][y + 1] >= 1 ||
				map[x - 1][y - 1] >= 1)
			{
				setting_is_possible = 0;
				break;
			}
			switch (dir)
			{
			case 0:
				x++;
				break;
			case 1:
				y++;
				break;
			case 2:
				x--;
				break;
			case 3:
				y--;
				break;
			}
		}
		// если есть возможность поставить корабль ставим
		if (setting_is_possible == 1) // условие, которое проверяет значение флага; если постановка корабля возможна, тогда только в этом случае будет производится запись
		{
			// расстановка начнется с нужных координат

			x = temp_x; // восстанавливаем значение переменных temp_x;
			y = temp_y; // восстанавливаем значение переменных temp_y;

			for (int i = 0; i < size_ship; i++)
			{
				map[x][y] = Ships_id; // записываем на карту индификатор корабля

				switch (dir)
				{
					// взависимости от направления меняем координату
				case 0:
					x++; // растет слева направо
					break;
				case 1:
					y++; // увеличиваем сверху вниз (от 0 до 24)
					break;
				case 2:
					x--; // уменьшаем, растет влево
					break;
				case 3:
					y--; // уменьшаем, растет вверх
					break;
				}
			}

			Ships[Ships_id] = size_ship;

			Ships_id++;
			count_ship++; // счетчик, который подсчитывает кол-во удачно установленных кораблей
		}
	}
}

void map_show(int map[N][N], int mask[N][N]) // данная функция выводит 1 параметр - ссылку на 2-х мерный массив map (игровое поле) на экран;
{
	// прорисовка поля и кораблей (используем вложенный цикл)
	// нумерация поля (строки)
	cout << ' ';
	for (int i = 0; i < N; i++)
	{
		cout << i;
	}
	cout << endl;
	for (int i = 0; i < N; i++)
	{
		// нумерация поля (столбцы)
		cout << i;

		for (int j = 0; j < N; j++)// проходим по всем элементам двухмерного массива map
		{
			// анализ соответствующей ячейки маски
			if (mask[j][i] == 1) // если равна 1 то выодим на экран содержимое массива map
			{
				if (map[j][i] == 0) // если ячейка равна нулю, то выводим прочерк - в остальных случаях корабль
				{
					cout << '-';
				}
				else if (map[j][i] == -1) // условие для маркировки корабля
				{
					cout << "X";
				}
				else
				{
					cout << map[j][i];
					//Sleep(4000);
				}
			}
			// если содержимое маски 0, то выводим на экран пробел ("туман войны")
			else
			{
				cout << ' ';
			}
		}
		cout << endl;
	}
}
int main() {

	setlocale(LC_ALL, "Russian");

	while (true)
	{
		int map[N][N] = { 0 }; 
		int mask[N][N] = { 0 };

		// блок вызова функции и создания кораблей
		set_rand_ships(map, 4, 1); // вызываем функцию и передаем в нее 3 параметра: 1 - массив map(передаем его по ссылке), 2 - размер корабля, 3 - кол-во кораблей. Корабль 4-х палубный - 1 шт.
		set_rand_ships(map, 3, 2); // 3 - х палубный корабль - 2 шт.
		set_rand_ships(map, 2, 3); // 2 -х палубный корабль - 3 шт.
		set_rand_ships(map, 1, 3); // однопалубный корабль - 4 шт.

		// Ввод координат ячейки по которой производится выстрел
		int x = 0, y = 0; // пользователь вводит в ручную координаты ячейки

		while (true)
		{
			// функция для прорисовки поля и кораблей выводим массив внутри нового цикла while, который осуществляеи ввод и проверку координат
			map_show(map, mask);

			cout << endl << "Введите координаты цели: " << endl;
			cin >> x;
			cin >> y;

			// условин проверки: попал или не попал
			if (map[x][y] >= 1)
			{
				Ships[map[x][y]]--;
				// проверка жизней
				if (Ships[map[x][y]] <= 0)
				{
					cout << "Убит" << endl;
				}
				else 
				{
					cout << "Ранен" << endl;
				}
				map[x][y] = -1; // помечаем палубу в которую попали


			}
			else
			{
				cout << "Промах" << endl;
			}
			mask[x][y] = 1; // помечаем ячейку единицей в случае попадания и отображаем её на экран

			Sleep(3000);
			system("cls"); // очищаем консольное окно
		}


	}

	system("pause");
	return 0;
}