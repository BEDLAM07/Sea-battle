#include <iostream>
#include <stdio.h> 
#include <math.h>
#include <string>
#include <fstream>
#include <windows.h> 
#include <time.h>
#include <conio.h>
#include <vector>


using namespace std;

const int N = 10; // размерность массива (поля)
const int NUM_SHIPS = 9;

int Ships_id = 1; // индификатор корабля
int Ships[10] = { 0 }; // целочисленный массив состоящий из 9 кораблей

// Функция переставляет курсор в заданной координате
void gotoxy(int x, int y)
{
	COORD p = { x, y };
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), p);
}

void ship_show(int x, int y, int dir, int size_ship)
{
	for (int i = 0; i < size_ship; i++)
	{
		gotoxy(x + 1, y + 1);
		cout << '#';

		switch (dir)
		{
		case 0:
			x++;
			break;
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		}
	}
};
// Функция проверки расположения корабля на карте
bool ship_in_map(int x, int y, int dir, int size_ship)
{
	bool in_map = 1; // флаг, по-умолчанию инициализируется начальное значение 1

		// проверка возможности постановки корабля
	for (int i = 0; i < size_ship; i++)
	{
		if (x < 0 || y < 0 || x >= N || y >= N)
		{
			in_map = 0; // "флаг", если постановка возможнна то флаг обнуляется. обнуляется начальное значение 1 если x и y окажутся за пределами границ массива
			break;
		}
		switch (dir)
		{
		case 0:
			x++;
			break;
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		}
	}
	return in_map;
}

// функция проверки постановки корабля
bool set_ship(int map[N][N], int x, int y, int dir, int size_ship)
{
	int temp_x = x; // временная переменная для хранения первоначальных координат x;
	int temp_y = y; // временная переменная для хранения первоначальных координат y;
	//int count_ship = 0; // инициализированная целочисленная переменная для подсчета кораблей 
	bool setting_is_possible = 1;

	// проверка возможности постановки корабля
	for (int i = 0; i < size_ship; i++)
	{
		if (x < 0 || y < 0 || x >= N || y >= N)
		{
			setting_is_possible = 0;
			break;
		}
		// условие проверки координат ячеек вокруг корабля
		if (map[x][y] >= 1 ||
			map[x][y + 1] >= 1 ||
			map[x][y - 1] >= 1 ||
			map[x + 1][y] >= 1 ||
			map[x + 1][y + 1] >= 1 ||
			map[x + 1][y - 1] >= 1 ||
			map[x - 1][y] >= 1 ||
			map[x - 1][y + 1] >= 1 ||
			map[x - 1][y - 1] >= 1)
		{
			setting_is_possible = 0;
			break;
		}
		switch (dir)
		{
		case 0:
			x++;
			break;
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		}
	}
	// если есть возможность поставить корабль ставим
	if (setting_is_possible == 1) // условие, которое проверяет значение флага; если постановка корабля возможна, тогда только в этом случае будет производится запись
	{
		// расстановка начнется с нужных координат

		x = temp_x; // восстанавливаем значение переменных temp_x;
		y = temp_y; // восстанавливаем значение переменных temp_y;

		for (int i = 0; i < size_ship; i++)
		{
			map[x][y] = Ships_id; // записываем на карту индификатор корабля

			switch (dir)
			{
				// взависимости от направления меняем координату
			case 0:
				x++; // растет слева направо
				break;
			case 1:
				y++; // увеличиваем сверху вниз (от 0 до 24)
				break;
			case 2:
				x--; // уменьшаем, растет влево
				break;
			case 3:
				y--; // уменьшаем, растет вверх
				break;
			}
		}

		Ships[Ships_id] = size_ship;

		Ships_id++;
		//count_ship++; // счетчик, который подсчитывает кол-во удачно установленных кораблей
	}
	return setting_is_possible;
}

void set_rand_ships(int map[N][N], int size_ship, int ship_id) // функция для установки случайных кораблей.
{

	int x, y;// объявляем переменные для хранения координатов первичного поля, поля от которого будет начинаться наращивание корабля
	int dir = 0; // переменная куда будет записываться значение случайного направления
	int count_ship = 0; // инициализированная целочисленная переменная для подсчета кораблей 

	int count_tact = 0; // счетчик числа тактов цикла while

	// второй цикл (определяем число кораблей)
	while (count_ship < 1)
	{
		count_tact++;

		if (count_tact > 100)
		{
			break;
		}

		// первичная позиция (генерация случайных координат)

		x = rand() % N;
		y = rand() % N;

		int temp_x = x; // временная переменная для хранения первоначальных координат x;
		int temp_y = y; // временная переменная для хранения первоначальных координат y;


		// генерация направления
		dir = rand() % 4; // генерируется случайное значение от нуля до трех

		bool setting_is_possible = 1; // флаг, по-умолчанию инициализируется начальное значение 1

		// проверка возможности постановки корабля
		for (int i = 0; i < size_ship; i++)
		{
			if (x < 0 || y < 0 || x >= N || y >= N)
			{
				setting_is_possible = 0; // "флаг", если постановка возможнна то флаг обнуляется. обнуляется начальное значение 1 если x и y окажутся за пределами границ массива
				break;
			}
			// условие проверки координат ячеек вокруг корабля
			if (map[x][y] >= 1 ||
				map[x][y + 1] >= 1 ||
				map[x][y - 1] >= 1 ||
				map[x + 1][y] >= 1 ||
				map[x + 1][y + 1] >= 1 ||
				map[x + 1][y - 1] >= 1 ||
				map[x - 1][y] >= 1 ||
				map[x - 1][y + 1] >= 1 ||
				map[x - 1][y - 1] >= 1)
			{
				setting_is_possible = 0;
				break;
			}
			switch (dir)
			{
			case 0:
				x++;
				break;
			case 1:
				y++;
				break;
			case 2:
				x--;
				break;
			case 3:
				y--;
				break;
			}
		}
		// если есть возможность поставить корабль ставим
		if (setting_is_possible == 1) // условие, которое проверяет значение флага; если постановка корабля возможна, тогда только в этом случае будет производится запись
		{
			// расстановка начнется с нужных координат

			x = temp_x; // восстанавливаем значение переменных temp_x;
			y = temp_y; // восстанавливаем значение переменных temp_y;

			for (int i = 0; i < size_ship; i++)
			{
				map[x][y] = ship_id; // записываем на карту индификатор корабля

				switch (dir)
				{
					// взависимости от направления меняем координату
				case 0:
					x++; // растет слева направо
					break;
				case 1:
					y++; // увеличиваем сверху вниз (от 0 до 24)
					break;
				case 2:
					x--; // уменьшаем, растет влево
					break;
				case 3:
					y--; // уменьшаем, растет вверх
					break;
				}
			}

			count_ship++; // счетчик, который подсчитывает кол-во удачно установленных кораблей
		}
	}
}

void map_show(int map[N][N], int mask[N][N], bool useMask) // данная функция выводит 1 параметр - ссылку на 2-х мерный массив map (игровое поле) на экран;
{
	// прорисовка поля и кораблей (используем вложенный цикл)
	// нумерация поля (строки)
	cout << ' ';
	for (int i = 0; i < N; i++)
	{
		cout << i;
	}
	cout << endl;
	for (int i = 0; i < N; i++)
	{
		// нумерация поля (столбцы)
		cout << i;

		for (int j = 0; j < N; j++)// проходим по всем элементам двухмерного массива map
		{
			// анализ соответствующей ячейки маски
			if (mask[j][i] == 1 || useMask == 0) // если равна 1 то выодим на экран содержимое массива map
			{
				if (map[j][i] == 0) // если ячейка равна нулю, то выводим прочерк - в остальных случаях корабль
				{
					cout << '-';
				}
				else if (map[j][i] == -1) // условие для маркировки корабля
				{
					cout << "X";
				}
				else if (map[j][i] == -2) // условие для маркировки клетки, где нет корабля
				{
					cout << ".";
				}
				else
				{
					cout << map[j][i];
				}
			}
			// если содержимое маски 0, то выводим на экран пробел ("туман войны")
			else
			{
				cout << ' ';
			}
		}
		cout << endl;
	}
}
// функция для реализации стрельбы
int shot(int map[N][N], int x, int y, int ships[NUM_SHIPS + 1], int mask[N][N])
{
	int result = 0; // переменная для определения результата стрельбы

	if (map[x][y] == -1 || map[x][y] == -2)
	{
		result = 3; // сигнал для бота для запуска генерации случайных координат
	}
	else if (map[x][y] >= 1)
	{
		ships[map[x][y]]--;
		// проверка жизней
		if (ships[map[x][y]] <= 0)
		{
			result = 2;
		}
		else
		{
			result = 1;
		}
		map[x][y] = -1; // помечаем палубу в которую попали
	}
	else
	{
		map[x][y] = -2; // отмечаем выстрел по карте (промах)
	}

	mask[x][y] = 1; // помечаем ячейку единицей в случае попадания и отображаем её на экран

	return result; // возвращаем result как результат работы функции
}

int main() {

	setlocale(LC_ALL, "Russian");

	while (true)
	{
		int map[N][N] = { 0 }; // массив для поля человека
		int map2[N][N] = { 0 }; // массив для поля ПК

		int ships1[NUM_SHIPS + 1] = { 0, 4, 3, 3, 2, 2, 2, 1, 1, 1 }; // размер кораблей задан в ручную
		int ships2[NUM_SHIPS + 1] = { 0, 4, 3, 3, 2, 2, 2, 1, 1, 1 };

		int mask[N][N] = { 0 }; // маска для поля человека
		int mask2[N][N] = { 0 }; // маска для поля компьютера



		//блок вызова функции и создания кораблей рандомно
		//вызываем функцию и передаем в нее 3 параметра: 1 - массив map(передаем его по ссылке), 2 - размер корабля, 3 - кол-во кораблей. корабль 4-х палубный - 1 шт.

		for (int i = 1; i <= NUM_SHIPS; i++)
		{
			set_rand_ships(map, ships1[i], i);
		}

		for (int i = 1; i <= NUM_SHIPS; i++)
		{
			set_rand_ships(map2, ships2[i], i);
		}

		int x = 0, y = 0; // переменные определяют начальную палубу корабля

		// переменная для хранения координат первого попадания
		int firstHitX = 0;
		int firstHitY = 0;

		// режим работы бота
		int mode = 0;

		// координаты для стрельбы
		int xBot = 0;
		int yBot = 0;

		int dir = 0; // направление стрельбы

		//вектор целых чисел
		vector <int> dirs;
		// направление векторов в обратном направление задал фиксированно
		dirs.push_back(3);
		dirs.push_back(2);
		dirs.push_back(1);
		dirs.push_back(0);

		//переменные отслеживают победителя
		bool winHuman = 0; // победа человека
		bool winBot = 0; // победа ПК

		// цикл переключения ввода между игроками
		bool turn = 1; // флаг, с помощью которого будет осуществляться передача хода.

		// главный цикл игры
		while (winHuman == false && winBot == false)
		{
			int resultShot = 0;

			//Цикл отвечающий за стрельбу одного из игроков(Человека или ПК)
			do
			{
				map_show(map, mask, 0);
				cout << endl;
				map_show(map2, mask2, 1);

				if (turn == 1)
				{
					cout << endl << "Введите координаты цели: ";
					cin >> x;
					cin >> y;
					resultShot = shot(map2, x, y, ships2, mask2); // вызов функции shot

					// анализируем результат выстрела и выводим его на экран
					if (resultShot == 1)
					{
						cout << "Ранен" << endl;
					}

					else if (resultShot == 2)
					{
						bool died = 1;
						for (int i = 1; i <= NUM_SHIPS; i++)
						{
							if (ships2[i] != 0)
							{
								died = 0;
								break;
							}
						}

						if (died == 1)
						{
							winHuman = 1;
							break;
						}

						cout << "Убит" << endl;
					}

					else
					{
						cout << "Промах" << endl;
					}
				}

				else
				{
					cout << endl << "Ход компьютера";
					cout << endl;
					Sleep(3000);

					// первый режим - 0 случайный поиск корабля (режим работы бота)
					if (mode == 0)
					{
						// цикл будит работать до тех пор пока бот не натолкнется на ячейку которую он ранее не обрабатывал
						do
						{
							xBot = rand() % N;
							yBot = rand() % N;

							resultShot = shot(map, xBot, yBot, ships1, mask);

						} while (resultShot == 3);

						if (resultShot == 1)
						{
							mode = 1;

							// переменные для запоминания первого попадания
							firstHitX = xBot;
							firstHitY = yBot;

							// условие проверки вектора на пустоту
							if (!dirs.empty())
							{
								dir = dirs[dirs.size() - 1]; // записываем в переменную последний элемент вектора и получаем доступ к последнему элементу
								dirs.pop_back(); // удаляем с помощью данного метода последний элемент
							}

							cout << "Ранен" << endl;
						}

						else if (resultShot == 2)
						{
							bool died = 1;
							for (int i = 1; i <= NUM_SHIPS; i++)
							{
								if (ships1[i] != 0)
								{
									died = 0;
									break;
								}
							}

							if (died == 1)
							{
								winBot = 1;
								break;
							}

							cout << "Убит" << endl;
						}

						else
						{
							cout << "Промах" << endl;
						}
					}
					// второй режим - 1;
					else if (mode == 1)
					{
						bool changeDir = 0; // переменная для отслеживания изменения направление (нужно менять или нет)

						if (dir == 0) // движение влево
						{
							if (xBot > 0)
								xBot--;
							else
							{
								changeDir = 1;
							}
						}
						else if (dir == 1) // движение вправо
						{
							if (xBot < N - 1)
								xBot++;
							else
							{
								changeDir = 1; // механизм буливских флагов
							}
						}
						else if (dir == 2) // движение вверх
						{
							if (yBot < 0)
								yBot--;
							else
							{
								changeDir = 1;
							}
						}
						else if (dir == 3) // движение вниз
						{
							if (yBot < N - 1)
								yBot++;
							else
							{
								changeDir = 1;
							}
						}
						// анализируем содержимое флага и извлекаем очередное направление из вектора направления координат
						if (changeDir == 1)
						{
							if (!dirs.empty())
							{
								dir = dirs[dirs.size() - 1];
								dirs.pop_back();
							}
							// координаты первой палубы, в которую первый раз попали
							xBot = firstHitX;
							yBot = firstHitY;

							//дополнительный ход для бота
							continue; // перекидываем управление программы в начало цикла для изменения координаты
						}
						resultShot = shot(map, xBot, yBot, ships1, mask);

						if (resultShot == 1)
						{
							cout << "Ранен" << endl;
						}

						else if (resultShot == 2)
						{
							mode = 0; // переключатель режима

							dirs.clear(); // удаляем полностью содержимое вектора

							 //восстанавливаем вектор в исходное состояние
							dirs.push_back(3);
							dirs.push_back(2);
							dirs.push_back(1);
							dirs.push_back(0);

							bool died = 1;
							for (int i = 1; i <= NUM_SHIPS; i++)
							{
								if (ships1[i] != 0)
								{
									died = 0;
									break;
								}
							}

							if (died == 1)
							{
								winBot = 1;
								break;
							}

							cout << "Убит" << endl;
						}

						else
						{
							// в момент совершения промаха бот меняет направление, извлекает из вектора
							if (!dirs.empty())
							{
								dir = dirs[dirs.size() - 1];
								dirs.pop_back();
							}
							xBot = firstHitX;
							yBot = firstHitY;

							cout << "Промах" << endl;
						}

					}
				}

				Sleep(3000);
				system("cls"); // очищаем консольное окно

			} while (resultShot != 0);

			turn = !turn; // инвертируем значение переменной turn для передачи хода
		}
		if (winHuman == true)
		{
			cout << "Вы победили!!!" << endl;
		}
		else if (winBot == true)
		{
			cout << "Вы проиграли!!!" << endl;
		}

		_getch();
		system("cls");
	}

	system("pause");

	return 0;

}